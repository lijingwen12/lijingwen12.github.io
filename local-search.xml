<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ts(简洁重新整理)</title>
    <link href="/2022/08/24/ts/"/>
    <url>/2022/08/24/ts/</url>
    
    <content type="html"><![CDATA[<h1 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h1><h2 id="一、安装和编译"><a href="#一、安装和编译" class="headerlink" title="一、安装和编译"></a>一、安装和编译</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 全局安装</span><br>npm install -g typescript<br><br><span class="hljs-comment">// TS不能直接运行,需要编译成js代码,再去运行js</span><br><span class="hljs-comment">// 编译</span><br>tsc greeter.<span class="hljs-property">ts</span><br><span class="hljs-comment">// 编译过后,同目录会出现一个名字相同的 greeter.js 文件</span><br>node greeter.<span class="hljs-property">js</span><br><br><span class="hljs-comment">// 此时每次修改ts文件,都需要重新编译</span><br><span class="hljs-comment">// 使用 tsc greeter.ts -w   &quot; -w &quot; 可以监听文件,帮我们自动编译</span><br><span class="hljs-comment">// 缺点: 一次只能监听一个ts文件</span><br>tsc greeter.<span class="hljs-property">ts</span> -w<br><br><span class="hljs-comment">// 想一次编译目录下所有 ts 文件</span><br><span class="hljs-comment">// 手动在目录下创建 tsconfig.json 文件(ts的配置文件)</span><br><span class="hljs-comment">// 里面内容只需要输入一个 &#123;&#125;</span><br>&#123;<br><br>&#125;<br><span class="hljs-comment">// 在目录下运行 tsc 就可以编译所有 ts 文件了</span><br></code></pre></td></tr></table></figure><h2 id="二、基础类型"><a href="#二、基础类型" class="headerlink" title="二、基础类型"></a>二、基础类型</h2><table><thead><tr><th>类型</th><th align="center">例子</th><th align="center">描述</th></tr></thead><tbody><tr><td>number</td><td align="center">1，-33，2.5</td><td align="center">任意数字</td></tr><tr><td>string</td><td align="center">“hello”,”wen”</td><td align="center">任意字符串</td></tr><tr><td>boolean</td><td align="center">true、false</td><td align="center">布尔值 true 或者 false</td></tr><tr><td>字面量</td><td align="center">其本身</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td>any</td><td align="center">*</td><td align="center">任意类型</td></tr><tr><td>unknown</td><td align="center">*</td><td align="center">类型安全的 any</td></tr><tr><td>void</td><td align="center">空值（undefined）</td><td align="center">没有值或者 undefined</td></tr><tr><td>never</td><td align="center">没有值</td><td align="center">不能是任何值</td></tr><tr><td>object</td><td align="center">{name: “zs”}</td><td align="center">js 对象</td></tr><tr><td>array</td><td align="center">[1,2,3]</td><td align="center">js 数组</td></tr><tr><td>tuple</td><td align="center">[4,5]</td><td align="center">元素，TS 新增类型，固定长度的数组</td></tr><tr><td>enum</td><td align="center">enum{A,B}</td><td align="center">枚举，TS 新增类型</td></tr></tbody></table><h4 id="基础类型声明"><a href="#基础类型声明" class="headerlink" title="基础类型声明"></a>基础类型声明</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义</span><br><span class="hljs-comment">// let 变量: 类型</span><br><span class="hljs-comment">// let 变量: 类型 = 值</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>;<br>num = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-comment">// 字面量 (一般不使用)</span><br><span class="hljs-comment">// 10 表示是 a 的类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">10</span>; <span class="hljs-comment">// ok</span><br>a = <span class="hljs-number">11</span>; <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 有时候可以这么使用</span><br><span class="hljs-comment">// 使用 | 来连接多个类型(联合类型)</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;hello&quot;</span> | <span class="hljs-string">&quot;world&quot;</span>;<br>b = <span class="hljs-string">&quot;hello&quot;</span>;<br>b = <span class="hljs-string">&quot;world&quot;</span>;<br><br><span class="hljs-comment">// 一般使用这个比较广泛</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">string</span>;<br>c = <span class="hljs-literal">true</span>;<br>c = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="any-unknown"><a href="#any-unknown" class="headerlink" title="any | unknown"></a>any | unknown</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// any 表示的是任意类型</span><br><span class="hljs-comment">// 不建议使用,相当于关闭TS类型检测</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">d</span>: <span class="hljs-built_in">any</span>;<br>d = <span class="hljs-number">10</span>;<br>d = <span class="hljs-string">&quot;hello&quot;</span>;<br>d = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 声明变量不指定类型,TS解析器会自动判断它为 any</span><br><span class="hljs-keyword">let</span> d;<br>d = <span class="hljs-number">10</span>;<br>d = <span class="hljs-string">&quot;hello&quot;</span>;<br>d = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 如果遇到不确定类型的变量的需求,可以使用 unknown</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">d</span>: <span class="hljs-built_in">unknown</span>;<br>d = <span class="hljs-number">10</span>;<br>d = <span class="hljs-string">&quot;hello&quot;</span>;<br>d = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// unknown 和 any 作用类似,都可以任意赋值</span><br><span class="hljs-comment">// 区别,any可以赋值给任意类型的变量,unknown则只能赋值给unknown类型的变量</span><br><span class="hljs-comment">// 此时如果使用any,赋值给其他类型的变量,会出现类型改变的效果,所以不建议使用</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-literal">false</span>;<br>str = a; <span class="hljs-comment">// ok</span><br>str = b; <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 如果想把值赋值给 指定类型的变量,有以下几种方式</span><br><span class="hljs-comment">// 1. 判断类型</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>  str = b;<br>&#125;<br><span class="hljs-comment">// 2. 类型断言</span><br><span class="hljs-comment">// 可以用来告诉解析器实际类型，前提是你确定它就是 string, 有两种写法</span><br>str = e <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br>str = &lt;<span class="hljs-built_in">string</span>&gt;e;<br></code></pre></td></tr></table></figure><h4 id="void-never"><a href="#void-never" class="headerlink" title="void | never"></a>void | never</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// void 用来表示空，一般用来表示函数没有返回值，</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fu</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;&#125;<br><br><span class="hljs-comment">// never 用来表示永远不会返回结果</span><br><span class="hljs-comment">// 比如抛错，程序抛错，不会进行下去，所以不会有返回结果</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;报错了！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在定义函数或是类时，如果遇到类型不明确就可以使用泛型<br>当然也可以，使用 any 解决，但是不推荐<br>因为，你只能知道，你的参数类型是 any 返回值类型也是 any, 不能确定你的参数类型和返回值类型是一样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 这时候可以使用泛型</span><br><span class="hljs-comment">// 名字可以任意取，T表示任意类型，具体类型是当函数调用时根据传参来确定</span><br><span class="hljs-comment">// (a: T)表示a 的类型 是T</span><br><span class="hljs-keyword">function</span> fn&lt;T&gt;(<span class="hljs-attr">a</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">// 可以直接调用</span><br><br><span class="hljs-comment">// 因为我传进入的参数的 number 类型，值为10</span><br><span class="hljs-comment">// 所以 T 就是 number 类型，参数 a 也是 number类型，返回值也是number类型</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 不指定泛型，TS自动对类型进行推断</span><br><br>fn&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 指定泛型</span><br><br><span class="hljs-comment">// 指定多个泛型</span><br><span class="hljs-keyword">function</span> fn2&lt;T, k&gt;(<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: K): T &#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-title function_">fn2</span>(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">// 建议书写时指定类型，更加直观</span><br>fn2&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-comment">// 有时候,任意的例如 T, K 类型范围过大</span><br><span class="hljs-comment">// 我们也可以使用 type 或者 interface 或 class 关键字处理</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> fn3&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Inter</span>&gt;(<span class="hljs-attr">a</span>: T): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> a.<span class="hljs-property">length</span>;<br>&#125;<br><span class="hljs-comment">// 这时候参数 a 必须能够实现 Inter 接口,也就是 a 必须拥有 length 属性才可以</span><br><span class="hljs-title function_">fn3</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// ok,字符串拥有length</span><br><span class="hljs-title function_">fn3</span>(<span class="hljs-number">122</span>); <span class="hljs-comment">// error,字符串拥有length</span><br><span class="hljs-title function_">fn3</span>(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">5</span> &#125;); <span class="hljs-comment">// ok,拥有length</span><br><br><span class="hljs-comment">// 除了 函数可以使用泛型, 类也可以使用泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">name</span>: T;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: T</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> mc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;zs&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript基础学习笔记</title>
    <link href="/2022/07/19/TypeScript/"/>
    <url>/2022/07/19/TypeScript/</url>
    
    <content type="html"><![CDATA[<h1 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h1><h2 id="一、基础类型"><a href="#一、基础类型" class="headerlink" title="一、基础类型"></a>一、基础类型</h2><p>typescript定义变量是时候，需要给变量添加类型说明。<br>比如定义boolean类型是时候需要在后面<code>: boolean</code>添加类型说明。</p><h4 id="1-boolean"><a href="#1-boolean" class="headerlink" title="1.boolean"></a>1.boolean</h4><p>最基本的数据类型就是简单的true&#x2F;false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span>= <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h4 id="2-number"><a href="#2-number" class="headerlink" title="2.number"></a>2.number</h4><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">decLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">hexLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0xf00d</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">binaryLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b1010</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">octalLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0o744</span>;<br></code></pre></td></tr></table></figure><h4 id="3-string"><a href="#3-string" class="headerlink" title="3.string"></a>3.string</h4><p>与JavaScript一样，可以使用双引号<code>&quot;&quot;</code>或单引号<code>&#39;&#39;</code>表示字符串<br>也可以使用模板字符串内嵌表达式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;liJIngWen&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">dataName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`2022-07-18 + <span class="hljs-subst">$&#123;name&#125;</span>`</span><br></code></pre></td></tr></table></figure><h4 id="4-Arr-数组"><a href="#4-Arr-数组" class="headerlink" title="4.Arr(数组)"></a>4.Arr(数组)</h4><p>两种方式<br>第二种使用了在JavaScript里面没有的数组泛型，<code>Array&lt;元素类型&gt;</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h4 id="5-元组"><a href="#5-元组" class="headerlink" title="5.元组"></a>5.元组</h4><p>元组类型是表示一个已知元素数量和类型的数组，各个元素的类型不必相同。<br>如下，定义一个<code>string</code>和<code>number</code>类型是元组.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br>x = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK</span><br>x = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]; <span class="hljs-comment">// Error，ts也会报不能类型number分配给类型string</span><br></code></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x[<span class="hljs-number">0</span>].<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// OK</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x[<span class="hljs-number">1</span>].<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Error, number类型上不存在substring</span><br></code></pre></td></tr></table></figure><p>当访问一个越界的元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br>x = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK</span><br>x[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;world&#x27;</span>; <span class="hljs-comment">// 不能将类型“&quot;world&quot;”分配给类型“undefined”。</span><br>x[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;world&#x27;</span>; <span class="hljs-comment">// Error,不能将类型“string”分配给类型“number”。</span><br></code></pre></td></tr></table></figure><h4 id="6-枚举（enum）"><a href="#6-枚举（enum）" class="headerlink" title="6.枚举（enum）"></a>6.枚举（enum）</h4><p><code>enum</code>是对JavaScript标准数据类型的一个补充。<br>使用枚举类型可以为一组数值赋予友好的名字。<br>默认情况下，<code>元素的编号</code>是从<code>0</code>开始的，也可以指定元素的编号，<strong>注意</strong>的是，下一个的编号总是上一个的编号<code>+1</code>，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Color</span>[<span class="hljs-number">0</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)    <span class="hljs-comment">// 打印 Red</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">// 打印 2</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Colors</span>[<span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>, b);  <span class="hljs-comment">// 打印 Blue</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Colors</span> &#123;<span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>=<span class="hljs-number">3</span>, <span class="hljs-title class_">Blue</span>, yellow, black=<span class="hljs-number">7</span>, brown&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Colors</span>);<br><span class="hljs-comment">//打印如下：</span><br>&#123;<br>  <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;Red&#x27;</span>,<br>  <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;Green&#x27;</span>,<br>  <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-string">&#x27;Blue&#x27;</span>,<br>  <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-string">&#x27;yellow&#x27;</span>,<br>  <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-string">&#x27;brown&#x27;</span>,<br>  <span class="hljs-title class_">Red</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-title class_">Green</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-title class_">Blue</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-attr">yellow</span>: <span class="hljs-number">5</span>,<br>  <span class="hljs-attr">black</span>: <span class="hljs-number">7</span>,<br>  <span class="hljs-attr">brown</span>: <span class="hljs-number">8</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-任意值"><a href="#7-任意值" class="headerlink" title="7.任意值"></a>7.任意值</h4><p>在定义变量的时候，还不确定变量的类型，可能来自用户的输入或者第三方库。这时候我希望能够通过编译，可以使用<code>any</code>关键字标记这些变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notValue</span>: <span class="hljs-built_in">any</span>;<br>notValue = <span class="hljs-string">&quot;Wen&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(notValue); <span class="hljs-comment">// Wen</span><br><br>notValue = <span class="hljs-literal">true</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(notValue); <span class="hljs-comment">// true</span><br><br>notValue = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(notValue); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p><code>any</code>在数组上也可以使用，当数组包含了不同类型，可以这样定义，在赋值的时候，也可以任意赋值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;str&quot;</span>];<br>list[<span class="hljs-number">0</span>] = <span class="hljs-literal">null</span>;<br>list[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>list[<span class="hljs-number">2</span>] = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;wen&quot;</span> &#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list)   <span class="hljs-comment">// [ null, true, &#123; name: &#x27;wen&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><h4 id="8-空值"><a href="#8-空值" class="headerlink" title="8.空值"></a>8.空值</h4><p>当一个函数没有返回值时，它的返回类型是<code>void</code><br>声明一个空值类型的意义不大，因为它只能赋值<code>undefined</code>和<code>null</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><h4 id="9-Null和Undefined"><a href="#9-Null和Undefined" class="headerlink" title="9.Null和Undefined"></a>9.Null和Undefined</h4><p><code>Null</code>和<code>Undefined</code>类型相当于是所有类型的子类型，其他类型是可以给他们赋值<code>Null</code>或<code>Undefined</code>的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p><strong>注意的是</strong>TypeScript 2.0 增加了对不可为空类型的支持。有一种新的严格空值检查模式，他提供了<code>strictNullChecks</code>来限制对空值的检查。可以通过在命令行上添加<code>--strictNullChecks</code>参数来启功严格空值检查。也可以在项目的<code>tsconfig.json</code>文件中启用<code>strictNullChecks</code>编译器选项。<br>在TS中，为了各版本的兼容，strictNullChecks的默认值是false</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;strictNullChecks&quot;</span>: <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在严格空值检查模式下，null和undefined无法赋值给其他类型的变量。例如下面的代码在<strong>strictNullChecks&#x3D;true</strong>下，语法虽然没错，但是<strong>无法通过编译</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">userName</span>: <span class="hljs-built_in">string</span>;<br>userName = <span class="hljs-string">&quot;小文&quot;</span>;  <span class="hljs-comment">// OK</span><br>userName = <span class="hljs-literal">null</span>;      <span class="hljs-comment">// OK</span><br>userName = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>在严格类型下，如果还想给变量赋值为空，需要使用联合类型，那么声明变量的时候需要这么声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">userName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br>userName = <span class="hljs-string">&quot;小文&quot;</span>;  <span class="hljs-comment">// OK</span><br>userName = <span class="hljs-literal">null</span>;      <span class="hljs-comment">// OK</span><br>userName = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Error</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;<br>age = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>在对象中也适用，并且的如果不想手动给age赋值，还可以这样定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> ;<br>  <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">user1</span>: <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小文&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-literal">undefined</span> &#125;; <span class="hljs-comment">// OK</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">user2</span>: <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小文&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;; <span class="hljs-comment">//OK</span><br><br><span class="hljs-comment">// 不手动赋值</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> ;<br>  age?:<span class="hljs-built_in">number</span> <br>&#125;;<br><span class="hljs-comment">// 此时，下面都是正确的</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">user1</span>: <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小文&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-literal">undefined</span> &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">user2</span>: <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小文&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span> &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">user3</span>: <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小文&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>在严格模式下，编译是还会有变量可空的安全检查，如果变量包含<code>null</code>或者<code>undefined</code>，则访问任何属性都会编译错误：<br>在访问属性时，需要变量值不能为空<br><strong>注意</strong>参数也有可能是函数类型，ts也会将该参数加上<code>undefined</code>类型，这时候也需要判断空值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">userName: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) &#123;  <span class="hljs-comment">// 编译错误</span><br>  <span class="hljs-keyword">return</span> userName.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">userName: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) &#123;  <span class="hljs-comment">// 编译成功</span><br>  <span class="hljs-keyword">if</span>(userName === <span class="hljs-literal">null</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> userName.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">callback?: () =&gt; <span class="hljs-built_in">void</span> </span>) &#123;  <span class="hljs-comment">// 编译成功</span><br>  <span class="hljs-keyword">if</span>(callback)&#123;<br>    <span class="hljs-title function_">callback</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-Never"><a href="#10-Never" class="headerlink" title="10.Never"></a>10.Never</h4><p><code>Never</code>类型表示的是那些永不存在的值类型。它是总会抛出异常或者没有返回值的函数表达式 或 箭头函数表达式的返回值类型，变量也有可能是<code>never</code>类型，仅当他们被永不为真的类型保护所约束时。<br><code>Never</code>类型也是任何类型的子类型，可以赋值给任何类型。只有<code>Never</code>类型能赋值给它本身，其他类型都不能赋值给<code>Never</code>，即使是<code>any</code>。<br>下面是一些返回never类型的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br><br><span class="hljs-comment">// 推断的返回值类型为never</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Something failed&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-类型断言"><a href="#11-类型断言" class="headerlink" title="11.类型断言"></a>11.类型断言</h4><p>当你在项目开发时，你很确切某个值是什么类型，你可以类型断言这种方式告诉编译器，类似于类型转换，它不影响运行结果，只是在编译阶段起作用。<br>它有两种使用方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 第一种：‘尖括号’语法</span><br><span class="hljs-keyword">let</span> len = (&lt;<span class="hljs-built_in">string</span>&gt;str).<span class="hljs-property">length</span>; <br><span class="hljs-comment">// 有兼容性问题, 在使用到了JSX的时候兼容性不是很好</span><br><br><span class="hljs-comment">// 第二种：as </span><br><span class="hljs-keyword">let</span> len = (str <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// 向编译器解释 str 就是string类型</span><br></code></pre></td></tr></table></figure><p>作用：当我在开发阶段，定义了一个<code>any</code>类型是值给用户输入，但是我确切知道，用户输入的是<code>string</code>类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;用户的输入&#x27;</span><br><span class="hljs-comment">// 当还是any的时候是没有.length的提示的</span><br><span class="hljs-keyword">let</span> len = (str <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(len);<br></code></pre></td></tr></table></figure><h2 id="二、变量声明"><a href="#二、变量声明" class="headerlink" title="二、变量声明"></a>二、变量声明</h2><p>略！<br><strong>注意</strong>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：<br>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>  p = <span class="hljs-number">12</span>;<br>  <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>) &#123;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br><span class="hljs-keyword">let</span> clone = &#123; ...c &#125;;<br>clone.<span class="hljs-property">p</span>; <span class="hljs-comment">// ok</span><br>clone.<span class="hljs-title function_">m</span>(); <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><h2 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p><h4 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h4><p>通过一小段代码，简单了解接口是怎么工作的，<code>printLabel</code>有一个参数，并且调用时，要求参数对象必须拥有一个<code>label</code>属性，类型是<code>string</code>。我们也可以传入有多个属性的对象，但必须要包含<code>label</code>属性且类型是<code>string</code>类型，类型检查器只会检查那些必需的属性是否存在，并且其类型是否匹配。如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labelledObj: &#123; label: <span class="hljs-built_in">string</span> &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labelledObj.<span class="hljs-property">label</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;<br><span class="hljs-title function_">printLabel</span>(myObj);<br></code></pre></td></tr></table></figure><p>使用接口重写上面的例子：必须包含一个label属性且类型为string：<br>其中<code>interface</code>是定义接口使用到的关键字，我们只在这里定义类型要求，其中<code>labelledObj: LabelledValue</code>表示，只要入参符合<code>LabelledValue</code>里面的类型要求，哪么就是允许的<br>还有一点值得提的是，<strong>类型检查器不会去检查属性的顺序</strong>，只要相应的属性存在并且类型也是对的就可以。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LabelledValue</span> &#123;<br>  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labelledObj: LabelledValue</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labelledObj.<span class="hljs-property">label</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> myObj = &#123;<span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span>&#125;;<br><span class="hljs-title function_">printLabel</span>(myObj); <span class="hljs-comment">// &#x27;Size 10 Object&#x27;</span><br><br>-----------------------<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LabelledValue</span> &#123;<br>  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labelledObj: LabelledValue</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labelledObj.<span class="hljs-property">label</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;<br><span class="hljs-title function_">printLabel</span>(myObj);  <br><span class="hljs-comment">// 编译报错：类型 &quot;&#123; size: number; label: string; &#125;&quot; 中缺少属性 &quot;age&quot;，但类型 &quot;LabelledValue&quot; 中需要该属性。</span><br></code></pre></td></tr></table></figure><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>在接口里的属性不一定都是必须的时候，只是在某些条件存在，选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。可以这么定义：<br>只需要在属性后面加<code>?</code>就可以了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LabelledValue</span> &#123;<br>  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labelledObj: LabelledValue</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labelledObj.<span class="hljs-property">label</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;<br><span class="hljs-title function_">printLabel</span>(myObj);   <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>可选属性好处一可以对可能存在的属性进行预定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>  color?: <span class="hljs-built_in">string</span>;<br>  width?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): &#123; <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">area</span>: <span class="hljs-built_in">number</span> &#125; &#123;<br>  <span class="hljs-keyword">let</span> newSquare = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">100</span> &#125;;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">color</span>) &#123;<br>    newSquare.<span class="hljs-property">color</span> = config.<span class="hljs-property">color</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">width</span>) &#123;<br>    newSquare.<span class="hljs-property">area</span> = config.<span class="hljs-property">width</span> * config.<span class="hljs-property">width</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newSquare;<br>&#125;<br><br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span> &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySquare);  <span class="hljs-comment">// &#123; color: &#x27;black&#x27;, area: 100 &#125;</span><br><br></code></pre></td></tr></table></figure><p>可选属性好处二可以捕获引用了不存在的属性时的错误<br>如果故意将<code>createSquare</code>里的<code>color</code>属性名拼错，就会得到一个错误提示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>  color?: <span class="hljs-built_in">string</span>;<br>  width?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): &#123; <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">area</span>: <span class="hljs-built_in">number</span> &#125; &#123;<br>  <span class="hljs-keyword">let</span> newSquare = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">100</span> &#125;;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">color</span>) &#123;<br>    newSquare.<span class="hljs-property">color</span> = config.<span class="hljs-property">clor</span>; <br>    <span class="hljs-comment">// 提示属性“clor”在类型“SquareConfig”上不存在。你是否指的是“color”? 在某行某列声明了 &#x27;color&#x27; day03.ts(2, 3): 在此处声明了 &quot;color&quot;。</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">width</span>) &#123;<br>    newSquare.<span class="hljs-property">area</span> = config.<span class="hljs-property">width</span> * config.<span class="hljs-property">width</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newSquare;<br>&#125;<br><br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span> &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySquare);<br><br></code></pre></td></tr></table></figure><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>定义只读属性，可以在属性名前面用<code>readonly</code>修饰<br>赋值后，x和y再也不能被改变了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span> &#125;;<br>p1.<span class="hljs-property">x</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，与<code>Array&lt;T&gt;</code>相似</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">&#x27;草莓&#x27;</span>, <span class="hljs-string">&#x27;樱桃&#x27;</span>,<span class="hljs-string">&#x27;苹果&#x27;</span>]<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;火龙果&#x27;</span> <span class="hljs-comment">// 类型“readonly string[]”中的索引签名仅允许读取</span><br></code></pre></td></tr></table></figure><p>但是<code>ReadonlyArray&lt;T&gt;</code>类型可以被其它相同类型的数组给赋值<br>不能将ReadonlyArray类型分配给Array类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">&quot;草莓&quot;</span>, <span class="hljs-string">&quot;樱桃&quot;</span>, <span class="hljs-string">&quot;苹果&quot;</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strArr</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;核桃&quot;</span>];<br>arr = strArr;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);   <span class="hljs-comment">// [ &#x27;核桃&#x27; ]</span><br>strArr = arr   <span class="hljs-comment">// Error 类型 &quot;readonly string[]&quot; 为 &quot;readonly&quot;，不能分配给可变类型 &quot;string[]&quot;。</span><br></code></pre></td></tr></table></figure><p>TypeScript为<code>Array&lt;Type&gt;</code>提供了简写方式<code>Type[]</code>，TypeScript也为<code>ReadonlyArray&lt;Type&gt;</code>提供了简写方式，写法为：<code>readonly Type[]</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt; =  [<span class="hljs-string">&#x27;西瓜&#x27;</span>, <span class="hljs-string">&#x27;荔枝&#x27;</span>,<span class="hljs-string">&#x27;芒果&#x27;</span>]<br><span class="hljs-comment">// 可以简写为</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strArr</span>: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;火龙果&#x27;</span>, <span class="hljs-string">&#x27;琵琶&#x27;</span>,<span class="hljs-string">&#x27;葡萄&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>Array</code>可以当成构造函数使用，而<code>ReadonlyArray</code>不能当成构造函数使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> fruitList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadonlyArray</span>(<span class="hljs-string">&#x27;草莓&#x27;</span>, <span class="hljs-string">&#x27;樱桃&#x27;</span>,<span class="hljs-string">&#x27;苹果&#x27;</span>) <br><span class="hljs-comment">// “ReadonlyArray”仅表示类型，但在此处却作为值使用</span><br><span class="hljs-keyword">const</span> fruitList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;草莓&#x27;</span>, <span class="hljs-string">&#x27;樱桃&#x27;</span>,<span class="hljs-string">&#x27;苹果&#x27;</span>) <br><span class="hljs-comment">// ok [ &#x27;草莓&#x27;, &#x27;樱桃&#x27;, &#x27;苹果&#x27; ]</span><br></code></pre></td></tr></table></figure><p><code>readonly</code>vs<code>const</code>，如果是用于变量使用，则使用<code>const</code>，若作为属性是话使用<code>readonly</code></p><h4 id="额外的属性检查（似懂非懂）"><a href="#额外的属性检查（似懂非懂）" class="headerlink" title="额外的属性检查（似懂非懂）"></a>额外的属性检查（似懂非懂）</h4><p>TypeScript在使用<code>字面量</code>的时候，会被特殊的对待，而且会经过额外属性检查，作为参数传递时，会检查属性和类型，只有属性和类型都满足的时候，才能通过，否则会报错，看如下代码，能更直观：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>  color?: <span class="hljs-built_in">string</span>;<br>  width?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): &#123; <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">area</span>: <span class="hljs-built_in">number</span> &#125; &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">5</span> &#125;;<br>&#125;<br><span class="hljs-comment">// 1. 这里故意添加一个SquareConfig没有的属性，然而却报错了</span><br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;ss&quot;</span>, <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <br><span class="hljs-number">100</span> &#125;);<br><br><span class="hljs-comment">// 2. 在故意输错一个属性的情况下，还是会报错</span><br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;);<br><br><span class="hljs-comment">// 3. 在仅输入一个正确的属性的情况下是 ok 的</span><br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;);<br></code></pre></td></tr></table></figure><p>为什么会说它是额外的检查，我们来回顾一下之前学习的一段代码：<br><strong>注意下面的代码</strong>，在同样的输入多一个的情况下，它是OK的，不同之处在于<code>参数并没有使用字面量去传参</code>，而是定义了一个<code>myObj</code>去接收它，然后再使用<code>myObj</code>去进行传参，这就是上面所说的使用字面量会经过额外属性检查。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LabelledValue</span> &#123;<br>  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labelledObj: LabelledValue</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labelledObj.<span class="hljs-property">label</span>);<br>&#125;<br><br><span class="hljs-comment">// 注意！这里我们也是在输入多一个的情况下，它是 ok </span><br><span class="hljs-keyword">let</span> myObj = &#123;<span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span>&#125;;<br><span class="hljs-title function_">printLabel</span>(myObj);<br></code></pre></td></tr></table></figure><p>想要绕开这个额外的检查很简单。<br>第一种就是上面所说的，使用变量去接收它，再进行使用就可以了。<br>第二种是最简单的方法，使用类型断言<br>官方推荐的最佳方式是，能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>  color?: <span class="hljs-built_in">string</span>;<br>  width?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): &#123; <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">area</span>: <span class="hljs-built_in">number</span> &#125; &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">5</span> &#125;;<br>&#125;<br><span class="hljs-comment">// ok</span><br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;ss&quot;</span>,<br>  <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">SquareConfig</span>);<br><br><span class="hljs-comment">// ------ 字符串索引 --------------</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小文的7月17</title>
    <link href="/2022/07/17/2022-07-17/"/>
    <url>/2022/07/17/2022-07-17/</url>
    
    <content type="html"><![CDATA[<p>今天看着文档修改了一下博客的布置，暂时还没想到要记录什么，感觉什么都没干已经到晚上了！</p>]]></content>
    
    
    <categories>
      
      <category>日常生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小文7月16号</title>
    <link href="/2022/07/16/%E5%B0%8F%E6%96%877%E6%9C%8816%E5%8F%B7/"/>
    <url>/2022/07/16/%E5%B0%8F%E6%96%877%E6%9C%8816%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p>小文在这一天并没有留下什么内容~~~~~~~</p>]]></content>
    
    
    <categories>
      
      <category>日常生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/16/hello-world/"/>
    <url>/2022/07/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
